RM = rm -f
RMDIR = rm -rf
MKDIR = mkdir -p
OBJSUFFIX = .o
INSTALL_X = install -m 0755
INSTALL_F = install -m 0644
CFLAGS ?= -Wall
CPPFLAGS = -Ilua/src -Isrc -Iunittest/googletest/googletest/include -Iunittest/googletest/googletest -MMD -MP -DHAVE_GIT_INFO
CXXFLAGS ?= $(CFLAGS) -fno-exceptions
CXXLIBFLAGS ?=
LDFLAGS += -L$(BUILDDIR) -ltundra
LIBCMD = "$(AR) "
LINKCMD = "$(CXX) -o "
PREFIX ?= /usr/local
CHECKED ?= no
UNIX := yes
ifeq ($(CHECKED), no)
CFLAGS += -O3 -DNDEBUG
BUILDDIR := build
else
CFLAGS += -g -D_DEBUG
BUILDDIR := build.checked
endif

CROSSMINGW ?= no
EXESUFFIX =

ifeq ($(CROSSMINGW), yes)
# Cross-compiling for windows on unix-like platform.
CROSS ?= x86_64-w64-mingw32-
CC := $(CROSS)gcc
CXX := $(CROSS)g++
AR := $(CROSS)ar rcus
CXXFLAGS += -std=gnu++11
CPPFLAGS += -D_WIN32 -DWINVER=0x0600 -D_WIN32_WINNT=0x0600 -D__MSVCRT_VERSION__=0x0601 -DFORCEINLINE='__inline __attribute__((always_inline))'
BUILDDIR := build.mingw
EXESUFFIX := .exe
else
CC ?= clang
CXX ?= clang++
AR= ar rcus

# Not cross-compiling. Detect options based on uname output.
UNAME := $(shell uname)
ifeq ($(UNAME), $(filter $(UNAME), FreeBSD NetBSD OpenBSD))
CC := clang
CXX := clang++
CXXFLAGS += -std=c++11
LDFLAGS += -lpthread
else
ifeq ($(UNAME), $(filter $(UNAME), Linux))
CC := clang
CXX := clang++
CXXFLAGS += -std=c++11
LDFLAGS += -pthread
else
ifeq ($(UNAME), $(filter $(UNAME), Darwin))
CXXFLAGS += -std=c++11
CXXFLAGS += -stdlib=libc++
LDFLAGS += -stdlib=libc++
else
ifeq ($(UNAME), $(filter $(UNAME), MINGW32_NT-5.1))
CXXFLAGS += -std=gnu++11
CPPFLAGS += -D_WIN32 -DWINVER=0x0501 -D_WIN32_WINNT=0x0501 -U__STRICT_ANSI__
EXESUFFIX := .exe
else
ifeq (MINGW32_NT, $(findstring MINGW32_NT, $(UNAME)))
CXXFLAGS += -std=gnu++11
CPPFLAGS += -D_WIN32 -DWINVER=0x0600 -D_WIN32_WINNT=0x0600 -D__MSVCRT_VERSION__=0x0601 -U__STRICT_ANSI__
EXESUFFIX := .exe
else
$(error "unknown platform $(UNAME)")
endif
endif
endif
endif
endif
endif

#Q ?= @
#E ?= @echo
Q ?=
E ?= @:

$(BUILDDIR)/%$(OBJSUFFIX): %.c
	@mkdir -p $(BUILDDIR)
	$(E) "CC $<"
	$(Q) $(CC) -c -o $@ $(CPPFLAGS) $(CFLAGS) $<

$(BUILDDIR)/%$(OBJSUFFIX): %.cpp
	@mkdir -p $(BUILDDIR)
	$(E) "CXX $<"
	$(Q) $(CXX) -c -o $@ $(CPPFLAGS) $(CXXFLAGS) $<


include Makefile.common

install:
	@echo "Installing Tundra2 to $(INSTALL_BASE)"
	$(MKDIR) $(INSTALL_DIRS)
	cd $(BUILDDIR) && $(INSTALL_X) $(FILES_BIN) $(INSTALL_BIN)
	cp -r scripts/* $(INSTALL_SCRIPT)
	@echo "Installation complete"

uninstall:
	@echo "Uninstalling Tundra2 from $(INSTALL_BASE)"
	$(RMDIR) $(UNINSTALL_DIRS)
	for file in $(FILES_BIN); do \
	  $(RM) $(INSTALL_BIN)/$$file; \
	  done
	@echo "Uninstallation complete"


$(BUILDDIR)/tundra-manual.html: doc/manual.asciidoc
	asciidoc -o $@ $^

ALL_SCRIPTS := $(shell find scripts -name \*.lua -or -name \*.xml)

INSTALL_PRODUCTS = \
	$(BUILDDIR)/tundra2$(EXESUFFIX) \
	$(BUILDDIR)/t2-inspect$(EXESUFFIX) \
	$(BUILDDIR)/t2-lua$(EXESUFFIX) \
	$(BUILDDIR)/PathControl$(EXESUFFIX) \
	$(BUILDDIR)/tundra-manual.html \
	$(ALL_SCRIPTS)

installer: $(BUILDDIR)/Tundra-Setup.exe
windows-zip: $(BUILDDIR)/Tundra-Binaries.zip

$(BUILDDIR)/Tundra-Binaries.zip: $(INSTALL_PRODUCTS)
	mkdir $(BUILDDIR)/__zip && \
	mkdir $(BUILDDIR)/__zip/tundra && \
	mkdir $(BUILDDIR)/__zip/tundra/bin && \
	mkdir $(BUILDDIR)/__zip/tundra/doc && \
	ln -s $$PWD/$(BUILDDIR)/tundra2$(EXESUFFIX) $(BUILDDIR)/__zip/tundra/bin/ && \
	ln -s $$PWD/$(BUILDDIR)/t2-inspect$(EXESUFFIX) $(BUILDDIR)/__zip/tundra/bin/ && \
	ln -s $$PWD/$(BUILDDIR)/t2-lua$(EXESUFFIX) $(BUILDDIR)/__zip/tundra/bin/ && \
	ln -s $$PWD/$(BUILDDIR)/tundra-manual.html $(BUILDDIR)/__zip/tundra/doc/ && \
	ln -s $$PWD/scripts $(BUILDDIR)/__zip/tundra/ && \
	(cd $(BUILDDIR)/__zip && zip -r -9 ../Tundra-Binaries.zip tundra) && \
	rm -rf $(BUILDDIR)/__zip


$(BUILDDIR)/Tundra-Setup.exe: \
	$(INSTALL_PRODUCTS) \
	windows-installer/tundra.nsi
	makensis -NOCD -DBUILDDIR=$(BUILDDIR) windows-installer/tundra.nsi > $(BUILDDIR)/nsis.log 2>&1

.PHONY: install uninstall installer win-zip
